# Документация к ORM

## Цель ORM

ORM (Object-Relational Mapping) представляет собой инструмент, который обеспечивает абстракцию базы данных, позволяя
разработчикам работать с объектами вместо прямой работы с SQL запросами. Целью нашей ORM является ознакомление с данной
технологией, упрощение взаимодействия с базой данных и облегчение процесса разработки.

## Основные компоненты

- **Класс Orm**: Класс Orm используется для передачи запросов в базу данных. Он реализован как Singleton, обеспечивая
  единственный экземпляр для работы с базой данных.

- **Класс Field и его наследники**: Используются для описания полей таблиц.

- **Класс Relation и его наследники**: Используются для описания связей между таблицами.

- **Класс Table**: Родительский класс для таблиц из базы данных. В нем необходимо определить название таблицы и ее поля.

## Класс ORM

### Методы

#### `__construct()`

Конструктор ORM создает подключение к базе данных на основе конфигурационных данных. В случае возникновения ошибок,
таких как проблемы с подключением или кодировкой, выбрасываются исключения.

#### `execute($sql)`

Метод `execute()` используется для выполнения SQL запросов. В случае ошибок во время выполнения запроса, выбрасывается
исключение, включающее в себя сам запрос для упрощения процесса отладки.

#### `select($table, $columns = '*', $where = '', $orderBy = '', $limit = '', $offset = '', $joins = [], $groupBy = '')`

Метод `select()` формирует и выполняет SELECT запрос к базе данных на основе переданных параметров.

#### `insert(string $table, array $data, $isIgnore = false)`

Метод `insert()` формирует и выполняет INSERT запрос на основе переданных данных. В случае необходимости, может
применять ключевое слово IGNORE для игнорирования дубликатов.

#### `update(string $table, array $data, string $where)`

Метод `update()` формирует и выполняет UPDATE запрос на основе переданных данных и условия.

#### `delete(string $table, string $where)`

Метод `delete()` формирует и выполняет DELETE запрос на основе переданного условия.

#### `executeMulti($sql)`

Метод `executeMulti()` используется для выполнения нескольких SQL запросов одновременно, например, для миграций.

#### Транзакции

- `begin()`: Начало транзакции.
- `commit()`: Фиксация транзакции.
- `rollback()`: Откат транзакции.

#### Затронутые строки и значение последнего автоинкремента

- `affectedRows()`: Возвращает количество затронутых строк при выполнении запроса.
- `last()`: Возвращает значение последнего автоинкремента.

## Пример использования

Пример использования класса ORM:

```php
<?php

// Получаем экземпляр ORM
$orm = Orm::getInstance();

// Выполняем SELECT запрос
$result = $orm->select('up_product', ['id', 'name', 'price'], 'price > 100');

// Используем полученные данные
while ($row = $result->fetch_assoc())
{
	echo "ID: {$row['id']}, Name: {$row['name']}\n";
}
```

## Class Field

### Описание

`Field` является абстрактным классом, реализующим интерфейс `FieldInterface`, и используется для описания полей таблиц
базы данных.

### Свойства

- **name**: Имя поля (необходимо называть его точно как в БД).
- **isPrimary**: Флаг, указывающий, является ли поле первичным ключом.
- **isNullable**: Флаг, указывающий, может ли поле содержать NULL значения.
- **isDefaultExists**: Флаг, указывающий, содержит ли поле значение по умолчанию.

### Методы

#### `__construct(string $name, bool $isPrimary = false, bool $isNullable = true, bool $isDefaultExists = false)`

#### Методы доступа к свойствам.

- `getName()`: Возвращает имя поля.
- `getType()`: Абстрактный метод, который должен быть реализован в дочерних классах и возвращает тип поля.
- `isPrimary():`: Возвращает true, если поле является первичным ключом, иначе false.
- `isNullable():`: Возвращает true, если поле может содержать NULL значения, иначе false.
- `isDefaultExists()`:Возвращает true, если поле содержит значение по умолчанию, иначе false.

### Наследники

- `IntegerField`: Является полем для целых числовых значений
- `FloatField`: Является полем для целых вещественных значений
- `StringField`: Является полем для целых строковых значений
- `BoleanField`: Является полем для целых булевых значений

## Class Relation

### Описание
`Relation` является абстрактным классом, расширяющим класс `Field`, и используется для описания отношений (связей) между таблицами в базе данных.

### Свойства
- **name**: Имя отношения (Рекомендуется называть как связанную таблицу).
- **referenceTable**: Класс таблицы, с которой устанавливается отношение.
- **condition**: Условие, определяющее отношение между таблицами.
- **joinType**: Тип соединения (по умолчанию `'LEFT'`).
- **isPrimary**: Флаг, указывающий, является ли отношение первичным ключом.
- **isNullable**: Флаг, указывающий, может ли отношение содержать NULL значения.
- **isDefaultExists**: Флаг, указывающий, содержит ли отношение значение по умолчанию.

### Методы

#### `public function __construct( string $name, Table $referenceTable, string $condition, string $joinType = 'LEFT', bool $isPrimary = false, bool $isNullable = true, bool $isDefaultExists = false)`

### Наследники
`Reference`, используется для создания связи **многие к одному**, в нём поле **condition** задается в виде:

'this.{**Имя поля**}=ref.{**Имя поля**}'

Где рядом с this задается имя поля самой таблицы, по которому создается связь, а рядом с ref задается имя поля в связанной таблицы.

`Reflection` используется для создания связи **один ко многим**, в нём поле **condition** задается в виде соответствующего имени отношения `Reference` в связанной таблицы

### Связь многие ко многим
Связь многие ко многим создаётся при помощи отдельных таблицы связи, в которых также поддерживаются и дополнительные данные. В этой таблице необходимо создать `Reference` поля ссылающиеся на соответсвующее таблицы. А в самих таблицах создать поля `Reflection`, ссылающиеся на соответсвующее поля `Reference` в таблице связи

### Пример использования

#### Один ко многим
У нас есть таблица пользователей, у одного пользователя может быть несколько заказов, а заказа может быть только один пользователь, для этого в таблице заказов хранится ID пользователя.
```php
// Создаём отношение с именем 'user' в таблице заказов, ссылаясь на таблицу пользователей UserTable, по нужному условию
new Reference('user', new UserTable, 'this.user_id=ref.id')
...
// Создаём отношение с именем 'order' в таблице пользователей, ссылаясь на таблицу OrderTable, указывая имя соответствующего отношения в связанной таблице
new Reflection('order', new OrderTable(), 'user')
```
#### Многие ко многим
У нас есть заказы, но у одного заказа может быть несколько продуктов, а продукты могут относиться к разным заказам. Для того чтобы описать подобные отношения, нам необходимо создать отдельную таблицу связи.
```php
// В таблице связи, для каждой из связанных таблиц создаем отношение по соответствующим условиям
new Reference('order', new OrderTable(), 'this.order_id=ref.id'),
new Reference('product', new ProductTable(), 'this.product_id=ref.id'),
...
// И в каждой из таблиц создаём соответствующие отношения, указывая соответсвующее имя отношения из таблицы связи
new Reflection('order_product', new OrderProductTable(), 'order')
...
new Reflection('order_product', new OrderProductTable(), 'product')
```

## Класс Table

`Table` - абстрактный класс, который предоставляет базовую функциональность для работы с таблицами базы данных.

### Методы

#### `add(array $data, $isIgnore = false): int`

Добавляет новую запись в таблицу.

- **Параметры:**
	- `$data`: Ассоциативный массив данных для вставки в таблицу.
	- `$isIgnore`: Опциональный параметр. Если установлен в `true`, запрос на вставку будет проигнорирован в случае возникновения дубликатов.
- **Возвращаемое значение:** Количество затронутых строк при выполнении запроса.

##### Пример 
```php
// Передаем ассоциативный массив, где ключ это имя поля, а значение это значение
UserTable::add(
			[
				'name' => $name,
				'surname' => $surname,
				'email' => $email,
				'password' => $password,
				'role_id' => $roleId,
				'tel' => $phoneNumber,
			]
		);
```
#### `update(array $data, array $condition): int`

Обновляет записи в таблице на основе заданных условий.

- **Параметры:**
	- `$data`: Ассоциативный массив данных для обновления.
	- `$condition`: Условие для выбора записей для обновления.
- **Возвращаемое значение:** Количество затронутых строк при выполнении запроса.

##### Пример
```php
// Передаем ассоциативный массив, где ключ это имя поля, а значение это значение
UserTable::update(
			[
				'name' => $name,
				'surname' => $surname,
				'email' => $email,
				'tel' => $phoneNumber,
				'password' => $password,
			], ['AND', ['=id' => $user->id]]
		);
// О том как составляется условие ($condition) ниже
```

#### `delete(array $condition): int`

Удаляет записи из таблицы на основе заданных условий.

- **Параметры:**
	- `$condition`: Условие для выбора записей для удаления.
- **Возвращаемое значение:** Количество затронутых строк при выполнении запроса.

##### Пример
```php
TagTable::delete(['AND', ['id' => $id]]);
// О том как составляется условие ($condition) ниже
```

#### `getMap(): array`

Абстрактный метод, который должен быть реализован в дочерних классах и возвращать массив, описывающий структуру полей таблицы.

- **Возвращаемое значение:** Массив, содержащий описание структуры полей таблицы.

#### `getTableName(): string`

Абстрактный метод, который должен быть реализован в дочерних классах и возвращать название таблицы базы данных.

- **Возвращаемое значение:** Название таблицы базы данных.

#### `getList(array $selectedColumns = ['*'], array $conditions = [], $orderBy = [], $limit = null, $offset = null)`

Получает список записей из таблицы на основе заданных условий.

- **Параметры:**
	- `$selectedColumns`: Массив выбранных столбцов. Если не передать выбранные столбцы или задать строго первым '*', то будут выбраны все столбцы, за исключением полей связи. Также всем полям можно задать алиасы, они задаются таким образом '{алиас}' => {'имя столбца'}. Столбцы связанных таблиц передаются таким образом: '{имя связи}' => массив полей, если им не задать массив полей, то там также будут выбраны все столбцы, кроме полей связи
	- `$conditions`: Массив условий для выборки.
	- `$orderBy`: Условие сортировки.
	- `$limit`: Ограничение количества записей.
	- `$offset`: Смещение для начала выборки записей.
- **Возвращаемое значение:** Результат запроса.

##### Пример
```php
// Мы получаем все поля таблицы ProductTable
// Далее мы получаем необходимые поля картинок, которые есть у продукта через отношение 'image', задаём алиас для id
// Далее мы через таблицу связи ProductTagTable обращаемся к таблице TagTable, где получаем всю поля тегов, но задаём алиас для id
$result =  ProductTable::getList([
					   '*',
					   'image' => ['image_id' => 'id', 'path'],
					   'product_tag' => ['tag' => ['*', 'tag_id' => 'id']],],
					   ['AND', ['=is_active' => 1]],
					   ['priority' => 'ASC'],
					   10,
					   2
					   )
// Мы можем задать необходимое нам условие (об этом ниже)
// Порядок сортировки с возможностью определять направление (ASC/DESC, по возрастанию/по убыванию)
// А также может задать limit и offset
```

### Внутренние методы

#### `formatCondition(string $condition, Table $referenceTable): string`

Преобразует условие для использования в запросе на основе заданной таблицы-ссылки.

- **Параметры:**
	- `$condition`: Условие для преобразования.
	- `$referenceTable`: Таблица-ссылка.
- **Возвращаемое значение:** Преобразованное условие.

#### `getFieldByName(string $name): ?Field`

Получает объект поля по его имени.

- **Параметры:**
	- `$name`: Имя поля.
- **Возвращаемое значение:** Объект поля или `null`, если поле не найдено.

#### `getColumnJoin(array $selectedColumns = ['*'], $joins = [])`

Производит объединение столбцов таблицы с ее зависимыми таблицами.

- **Параметры:**
	- `$selectedColumns`: Массив выбранных столбцов.
	- `$joins`: Массив сведений о соединениях таблиц.
- **Возвращаемое значение:** Массив с информацией о столбцах, соединениях и псевдонимах.

#### `makeWhere($logicCondition, $conditions, $alias = []): string`

Формирует условие для оператора WHERE в SQL-запросе на основе заданных условий и псевдонимов.

- **Параметры:**
	- `$logicCondition`: Логическое условие (AND или OR).
	- `$conditions`: Условия для формирования.
	- `$alias`: Псевдонимы столбцов таблицы.
- **Возвращаемое значение:** Сформированное условие для оператора WHERE.

#### `makeOrderBy($orderBy, $alias): string`

Формирует условие сортировки для SQL-запроса на основе заданных условий и псевдонимов.

- **Параметры:**
	- `$orderBy`: Условие сортировки.
	- `$alias`: Псевдонимы столбцов таблицы.
- **Возвращаемое значение:** Сформированное условие сортировки.

#### `prepareString($string): string`

Подготавливает строку для безопасного использования в SQL-запросе. Если передать не строку, то значение просто вернется

- **Параметры:**
	- `$string`: Строка для подготовки.
- **Возвращаемое значение:** Подготовленная строка.

#### `getAllColumns() : array`

Возвращает все колонки таблицы, за исключением полей отношений таблицы.

- **Возвращаемое значение** Массив имен колонок.

### Про $condition
$condition передается в виде массива ['{Логическое условие (AND или OR)}', [{Массив условий}]]. Условия могут быть вложенные, такое условие задается следующим образом '{Логическое условие}' => [{Массив вложенных условий}].